/*
 * MIT License
 *
 * Copyright (c) 2023 LiMuYang
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package okcronet

import okcronet.http.Cookie
import okcronet.http.CookieJar
import okcronet.http.Headers
import okcronet.http.HttpUrl.Companion.toHttpUrl
import okio.Buffer
import okio.BufferedSink
import okio.Source
import okio.Timeout
import okio.buffer
import okio.sink
import okio.use
import org.chromium.net.CronetException
import org.chromium.net.UrlRequest
import org.chromium.net.UrlResponseInfo
import java.io.File
import java.io.IOException
import java.io.OutputStream
import java.nio.ByteBuffer
import java.nio.charset.Charset
import java.util.concurrent.ArrayBlockingQueue
import java.util.concurrent.Future
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicBoolean

/**
 * Cronet 回调的实现类，这是涉及到异步到同步转换的核心的桥梁。
 * 此类完成了核心的数据接收工作。可继承此类，用于实现想要的数据类型。
 *
 * An implementation of the Cronet callback.
 * This is the bridge that comes to the core of the asynchronous to synchronous conversion.
 * This class completes the core data reception work.
 * This class can be inherited for implementing the desired data type.
 */
open class SourceCallback(readTimeoutMillis: Long, private val cookieJar: CookieJar?, private val isFollowRedirect: Boolean) :
    UrlRequest.Callback() {

    constructor(readTimeoutMillis: Long) : this(readTimeoutMillis, null, true)

    constructor(readTimeoutMillis: Long, cookieJar: CookieJar?) : this(readTimeoutMillis, cookieJar, true)

    /** BodySource 和 UrlResponseInfo 的 Future  */
    private val mFuture = CompletableFutureCompat<Pair<Source, UrlResponseInfo>>()

    /** 指定的读取超时  */
    private val readTimeoutMillis: Long

    /**
     * Cronet 的异步回调生成的阻塞数据流读 Source。
     *
     * The blocking stream generated by the Cronet asynchronous callback reads the Source.
     */
    @Volatile
    private var cronetBodySource: CronetBodySource? = null

    init {
        require(readTimeoutMillis >= 0)

        if (readTimeoutMillis == 0L) {
            this.readTimeoutMillis = Long.MAX_VALUE
        } else {
            this.readTimeoutMillis = readTimeoutMillis
        }
    }

    /**
     * 返回与此 cronet 请求回调关联的 Source 。
     *
     * 请注意，在流式传输响应正文时，从此获取 Source 数据可能会阻塞。
     *
     * Returns the Source associated with this cronet request callback.
     *
     * Please note that when streaming the response body, getting Source data from this may block.
     */
    val responseFuture: Future<Pair<Source, UrlResponseInfo>>
        get() = mFuture

    /**
     * 同步等待获取 Source 数据。阻塞调用。
     *
     * Synchronously waits to get Source data. Blocking calls.
     */
    val source: Source
        @Throws(IOException::class)
        get() = mFuture.getValue().first


    val urlResponseInfo: UrlResponseInfo
        @Throws(IOException::class)
        get() = mFuture.getValue().second

    /**
     * 网络返回的 Http Code。阻塞调用。
     *
     * The HTTP code returned by the network. Blocking calls.
     */
    val code: Int get() = responseFuture.getValue().second.httpStatusCode

    /**
     * 网络是否请求成功。阻塞调用。
     *
     * Whether the network request is successful. Blocking calls.
     */
    fun isSuccess() = code in 200..299

    /**
     * HTTP状态消息。阻塞调用。
     *
     * HTTP status message. Blocking calls.
     */
    val message: String get() = responseFuture.getValue().second.httpStatusText

    override fun onRedirectReceived(
        urlRequest: UrlRequest, urlResponseInfo: UrlResponseInfo, nextUrl: String
    ) {
        if (isFollowRedirect) {
            urlRequest.followRedirect()
        }
    }

    override fun onResponseStarted(urlRequest: UrlRequest, urlResponseInfo: UrlResponseInfo) {
        cronetBodySource = CronetBodySource(urlRequest, readTimeoutMillis).apply {
            check(mFuture.complete(this to urlResponseInfo))
        }
    }

    override fun onReadCompleted(
        urlRequest: UrlRequest, urlResponseInfo: UrlResponseInfo, byteBuffer: ByteBuffer
    ) {
        cronetBodySource?.add(
            CronetBodySource.CronetResult.ReadCompleted(byteBuffer)
        )
    }

    override fun onSucceeded(urlRequest: UrlRequest, urlResponseInfo: UrlResponseInfo) {
        // 保存cookie
        if (!urlResponseInfo.wasCached() && cookieJar != null) {
            val cronetHeaders = urlResponseInfo.allHeadersAsList
            if (cronetHeaders.isNotEmpty()) {
                // 保存 cookie.  save cookie
                val headerBuilder: Headers.Builder = Headers.Builder()

                cronetHeaders.forEach {
                    headerBuilder.add(it.key.trim(), it.value.trim())
                }

                val url = urlResponseInfo.url.toHttpUrl()
                cookieJar.save(url, Cookie.parseAll(url, headerBuilder.build()))
            }
        }

        cronetBodySource?.add(CronetBodySource.CronetResult.Success)
    }

    override fun onFailed(
        urlRequest: UrlRequest, urlResponseInfo: UrlResponseInfo?, e: CronetException
    ) {
        if (mFuture.completeExceptionally(e)) {
            return
        }

        // If this was called as a reaction to a read() call, the read result will propagate
        // the exception.
        cronetBodySource?.add(
            CronetBodySource.CronetResult.Failed(e)
        )
    }

    override fun onCanceled(urlRequest: UrlRequest, responseInfo: UrlResponseInfo?) {
        cronetBodySource?.canceled()
        cronetBodySource?.add(
            CronetBodySource.CronetResult.Canceled
        )

        // If there's nobody listening it's possible that the cancellation happened before we even
        // received anything from the server. In that case inform the thread that's awaiting server
        // response about the cancellation as well. This becomes a no-op if the futures
        // were already set.
        val e = IOException("The request was canceled!")
        mFuture.completeExceptionally(e)
    }

    private class CronetBodySource(
        private val request: UrlRequest,
        private val readTimeoutMillis: Long
    ) : Source {

        // bufferRead: 当前供 sink 读取的数据（消费者用）
        private var bufferRead: ByteBuffer? = ByteBuffer.allocateDirect(BUFFER_SIZE).apply { flip() } // 初始为空（limit=0）

        // bufferFill: 当前供 Cronet 填充的数据（生产者用）
        private var bufferFill: ByteBuffer? = ByteBuffer.allocateDirect(BUFFER_SIZE)

        // 队列用于传递“填满数据的 Buffer”或者“错误/结束信号”
        // 容量设为 1 即可，因为我们要严格控制流转：Fill 好了才能给 Read 用
        private val filledBuffers = ArrayBlockingQueue<CronetResult>(1)

        private val finished = AtomicBoolean(false)
        private val canceled = AtomicBoolean(false)
        @Volatile private var closed = false

        // 标记是否已经发出了网络读取请求
        private var isReadingNetwork = false

        init {
            // 初始化时，立即触发第一次网络读取
            requestReadNextChunk()
        }

        /**
         * 触发网络读取。只有当 bufferFill 处于可用状态时才调用。
         */
        private fun requestReadNextChunk() {
            if (finished.get() || closed || canceled.get()) return

            // 确保 bufferFill 是清空状态，准备接收数据
            bufferFill?.clear()

            // 标记正在读取，防止重复触发
            isReadingNetwork = true
            try {
                bufferFill?.let { request.read(it) }
            } catch (e: Exception) {
                // 如果同步抛出异常（极少见），手动入队失败结果
                filledBuffers.offer(CronetResult.Failed(CronetExceptionImplWrapper(e)))
            }
        }

        @Throws(IOException::class)
        override fun read(sink: Buffer, byteCount: Long): Long {
            if (canceled.get()) throw IOException("The request was canceled!")
            check(!closed) { "CronetBodySource closed" }

            var currentBuf = bufferRead

            // 如果当前读取缓冲区没数据了，尝试交换缓冲区
            if (currentBuf == null || !currentBuf.hasRemaining()) {

                // 如果 buffer 耗尽了，且标记为已完成，说明真正结束了
                if (finished.get()) {
                    return -1
                }

                // 此时 bufferRead 已经空了，它可以变成 bufferFill 去接收下一次数据
                // 但为了避免多线程竞争，我们先暂存这个空 buffer，等拿到新数据后再赋值给 member field
                val emptyBuffer = currentBuf
                emptyBuffer?.clear() // 重置状态

                // 阻塞等待 Cronet 填好的数据
                val result = try {
                    filledBuffers.poll(readTimeoutMillis, TimeUnit.MILLISECONDS)
                } catch (_: InterruptedException) {
                    Thread.currentThread().interrupt()
                    null
                }

                if (result == null) {
                    request.cancel()
                    throw CronetTimeoutException()
                }

                when (result) {
                    is CronetResult.ReadCompleted -> {
                        // 拿到了新数据，它原本是 bufferFill
                        val newReadBuffer = result.buffer
                        newReadBuffer.flip() // 切换为读模式

                        // 将刚才空的 bufferRead 变成新的 bufferFill
                        // 注意：这里完成了“双缓冲交换”
                        // 之前的 bufferFill 变成了现在的 bufferRead
                        // 之前的 bufferRead 变成了现在的 bufferFill
                        this.bufferRead = newReadBuffer
                        this.bufferFill = emptyBuffer

                        currentBuf = newReadBuffer

                        // 立即触发下一次预取（Prefetch），让 Cronet 去填这个空的 bufferFill
                        // 这样在我们消费 bufferRead 的时候，网络就在并行下载了
                        requestReadNextChunk()
                    }
                    is CronetResult.Success -> {
                        finished.set(true)
                        cleanUp()
                        return -1
                    }
                    is CronetResult.Failed -> {
                        finished.set(true)
                        cleanUp()
                        throw IOException(result.exception)
                    }
                    is CronetResult.Canceled -> {
                        cleanUp()
                        throw IOException("The request was canceled!")
                    }
                }
            }

            // 2. 读取逻辑
            val validBuf = currentBuf

            val bytesToRead = minOf(byteCount, validBuf.remaining().toLong()).toInt()

            if (bytesToRead > 0) {
                val originalLimit = validBuf.limit()
                validBuf.limit(validBuf.position() + bytesToRead)
                sink.write(validBuf)
                validBuf.limit(originalLimit)
            }

            return bytesToRead.toLong()
        }

        // 将结果注入队列，供 read() 方法消费
        fun add(callbackResult: CronetResult) {
            // 无论成功失败，都放入队列解除 read() 的阻塞
            // 如果队列满了（理论上不应该，因为我们是严格的 ping-pong），offer 会返回 false
            if (!filledBuffers.offer(callbackResult)) {
                // Should not happen in strict ping-pong
            }
        }

        fun canceled() {
            if (canceled.getAndSet(true)) return

            // 即使取消了，也要给队列塞个结果，防止 read() 死锁
            filledBuffers.offer(CronetResult.Canceled)

            cleanUp()
        }

        override fun close() {
            if (closed) return
            closed = true
            if (!finished.get()) request.cancel()
            // 清理资源
            cleanUp()
        }

        private fun cleanUp() {
            bufferRead = null
            bufferFill = null
        }

        override fun timeout(): Timeout = Timeout.NONE

        class CronetExceptionImplWrapper(e: Throwable) : CronetException(e.message, e)

        sealed class CronetResult {
            class ReadCompleted(val buffer: ByteBuffer) : CronetResult()

            data object Success : CronetResult()

            class Failed(val exception: CronetException?) : CronetResult()

            data object Canceled : CronetResult()
        }

        companion object {
            // 32KB
            private const val BUFFER_SIZE = 32 * 1024
        }
    }


    companion object {

        /**
         * 扩展方法
         * 获取结果，并写入到 BufferedSink
         */
        fun SourceCallback.writeTo(bufferedSink: BufferedSink) =
            bufferedSink.use { sink ->
                source.use { s ->
                    sink.writeAll(s).apply {
                        sink.flush()
                    }
                }
            }

        /**
         * 扩展方法
         * 获取结果，并写入到 OutputStream
         */
        fun SourceCallback.writeTo(outputStream: OutputStream) =
            writeTo(outputStream.sink().buffer())

        /**
         * 扩展方法
         * 获取结果，并写入到 File
         */
        fun SourceCallback.writeTo(file: File) = writeTo(file.sink().buffer())


        /**
         * 扩展方法
         * 获取 String 类型的结果
         */
        fun SourceCallback.string(): String {
            return source.buffer().readString(
                getCharsetFromHeaders(urlResponseInfo)
            )
        }

        private fun getCharsetFromHeaders(info: UrlResponseInfo): Charset {
            // Header 中获取 Content-Type，查找编码类型
            info.allHeaders["Content-Type"]?.forEach {
                it.split(";").forEach { type ->
                    if (type.trim().startsWith("charset", true)) {
                        type.split("=").lastOrNull()?.let { c ->
                            return Charset.forName(c.trim())
                        }
                    }
                }
            }

            return Charset.defaultCharset()
        }
    }
}